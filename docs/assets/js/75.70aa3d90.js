(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{235:function(e,a,t){"use strict";t.r(a);var r=t(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"vue实现数据驱动视图的核心原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue实现数据驱动视图的核心原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue实现数据驱动视图的核心原理")]),e._v(" "),t("h3",{attrs:{id:"一-什么是数据驱动视图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-什么是数据驱动视图","aria-hidden":"true"}},[e._v("#")]),e._v(" 一 什么是数据驱动视图")]),e._v(" "),t("p",[e._v("数据驱动是vuejs最大的特点。在vuejs中，所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。")]),e._v(" "),t("h3",{attrs:{id:"二-mvvm框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-mvvm框架","aria-hidden":"true"}},[e._v("#")]),e._v(" 二 MVVM框架")]),e._v(" "),t("p",[e._v("Vuejs的数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewmodel。")]),e._v(" "),t("p",[e._v("1， Model:指的是数据部分，对应到前端就是javascript对象")]),e._v(" "),t("p",[e._v("2， View:指的是视图部分，对应前端就是dom")]),e._v(" "),t("p",[e._v("3， Viewmodel:就是连接视图与数据的中间件")]),e._v(" "),t("p",[e._v("注：数据(Model)和视图(View)是不能直接通讯的，而是需要通过ViewModel来实现双方的通讯。当数据变化的时候，viewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，viewMOdel也能够监听到事件，并通知model进行响应。Viewmodel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作")]),e._v(" "),t("h1",{attrs:{id:"defineproperty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty","aria-hidden":"true"}},[e._v("#")]),e._v(" defineProperty")]),e._v(" "),t("h3",{attrs:{id:"语法："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法：","aria-hidden":"true"}},[e._v("#")]),e._v(" 语法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("object.defineProperty（obj，prop，descriptor）\nobj: 需要定义属性的对象\nprop：需要定义或修改的属性名称\ndescript：将要被定义或修改的属性描述符\n")])])]),t("h3",{attrs:{id:"返回值："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#返回值：","aria-hidden":"true"}},[e._v("#")]),e._v(" 返回值：")]),e._v(" "),t("p",[e._v("被传递给函数的对象")]),e._v(" "),t("h3",{attrs:{id:"属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性","aria-hidden":"true"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),t("h4",{attrs:{id:"_1，-writable-属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1，-writable-属性","aria-hidden":"true"}},[e._v("#")]),e._v(" 1， Writable 属性")]),e._v(" "),t("p",[e._v("当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。"),t("br"),e._v("\n当writable属性设置为false时，该属性被称为“不可写”。它不能被重新分配。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var o = {}; // Creates a new object\n\nObject.defineProperty(o, 'a', {\n  value: 37,\n  writable: false\n});\n\nconsole.log(o.a); // logs 37\no.a = 25; // No error thrown\n// (it would throw in strict mode, even if the value had been the same)\nconsole.log(o.a); // logs 37. The assignment didn't work.\n")])])]),t("h4",{attrs:{id:"_2，configurable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2，configurable","aria-hidden":"true"}},[e._v("#")]),e._v(" 2，configurable")]),e._v(" "),t("p",[e._v("当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。")]),e._v(" "),t("h4",{attrs:{id:"_3，enumerable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3，enumerable","aria-hidden":"true"}},[e._v("#")]),e._v(" 3，enumerable")]),e._v(" "),t("p",[e._v("当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。")]),e._v(" "),t("h4",{attrs:{id:"_4，value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4，value","aria-hidden":"true"}},[e._v("#")]),e._v(" 4，value")]),e._v(" "),t("p",[e._v("该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。")]),e._v(" "),t("h4",{attrs:{id:"_5，get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5，get","aria-hidden":"true"}},[e._v("#")]),e._v(" 5，get")]),e._v(" "),t("p",[e._v("一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。\n默认为 undefined。")]),e._v(" "),t("h4",{attrs:{id:"_6，set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6，set","aria-hidden":"true"}},[e._v("#")]),e._v(" 6，set")]),e._v(" "),t("p",[e._v("一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。\n默认为 undefined。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Archiver() {\n  var temperature = null;\n  var archive = [];\n\n  Object.defineProperty(this, 'temperature', {\n    get: function() {\n      console.log('get!');\n      return temperature;\n    },\n    set: function(value) {\n      temperature = value;\n      archive.push({ val: temperature });\n    }\n  });\n\n  this.getArchive = function() { return archive; };\n}\n\nvar arc = new Archiver();\narc.temperature; // 'get!'\narc.temperature = 11;\narc.temperature = 13;\narc.getArchive(); // [{ val: 11 }, { val: 13 }]\n")])])]),t("h3",{attrs:{id:"继承属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承属性","aria-hidden":"true"}},[e._v("#")]),e._v(" 继承属性")]),e._v(" "),t("p",[e._v("如果访问者的属性是被继承的，它的 get 和set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。")])])}],!1,null,null,null);a.default=s.exports}}]);